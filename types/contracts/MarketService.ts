/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export declare namespace IMarketService {
  export type NFTStruct = {
    isSupport: PromiseOrValue<boolean>;
    listingFee: PromiseOrValue<BigNumberish>;
    auctionFee: PromiseOrValue<BigNumberish>;
    nftTeam: PromiseOrValue<string>;
    percentNFTTeam: PromiseOrValue<BigNumberish>;
  };

  export type NFTStructOutput = [
    boolean,
    BigNumber,
    BigNumber,
    string,
    BigNumber
  ] & {
    isSupport: boolean;
    listingFee: BigNumber;
    auctionFee: BigNumber;
    nftTeam: string;
    percentNFTTeam: BigNumber;
  };
}

export declare namespace MarketService {
  export type AuctionStruct = {
    isEnded: PromiseOrValue<boolean>;
    nft: PromiseOrValue<string>;
    winner: PromiseOrValue<string>;
    owner: PromiseOrValue<string>;
    currency: PromiseOrValue<string>;
    tokenId: PromiseOrValue<BigNumberish>;
    fee: PromiseOrValue<BigNumberish>;
    bid: PromiseOrValue<BigNumberish>;
    bidDuration: PromiseOrValue<BigNumberish>;
    end: PromiseOrValue<BigNumberish>;
    id: PromiseOrValue<BigNumberish>;
  };

  export type AuctionStructOutput = [
    boolean,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    isEnded: boolean;
    nft: string;
    winner: string;
    owner: string;
    currency: string;
    tokenId: BigNumber;
    fee: BigNumber;
    bid: BigNumber;
    bidDuration: BigNumber;
    end: BigNumber;
    id: BigNumber;
  };

  export type ListingStruct = {
    isEnded: PromiseOrValue<boolean>;
    nft: PromiseOrValue<string>;
    currency: PromiseOrValue<string>;
    owner: PromiseOrValue<string>;
    buyer: PromiseOrValue<string>;
    tokenId: PromiseOrValue<BigNumberish>;
    fee: PromiseOrValue<BigNumberish>;
    price: PromiseOrValue<BigNumberish>;
    id: PromiseOrValue<BigNumberish>;
  };

  export type ListingStructOutput = [
    boolean,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    isEnded: boolean;
    nft: string;
    currency: string;
    owner: string;
    buyer: string;
    tokenId: BigNumber;
    fee: BigNumber;
    price: BigNumber;
    id: BigNumber;
  };
}

export interface MarketServiceInterface extends utils.Interface {
  functions: {
    "CREATE_AUCTION_TYPE_HASH()": FunctionFragment;
    "DEFAULT_ADMIN_ROLE()": FunctionFragment;
    "DOMAIN_TYPE_HASH()": FunctionFragment;
    "END_AUCTION_TYPE_HASH()": FunctionFragment;
    "LIST_TYPE_HASH()": FunctionFragment;
    "OPERATION_ROLE()": FunctionFragment;
    "OWNER_ROLE()": FunctionFragment;
    "UN_LIST_TYPE_HASH()": FunctionFragment;
    "bid(uint256,uint256)": FunctionFragment;
    "buy(uint256,uint256)": FunctionFragment;
    "buyPackage(uint256,uint256)": FunctionFragment;
    "createAuction(address,uint256,uint256,address,uint256)": FunctionFragment;
    "createAuctionBySig(address,uint256,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "cvWithdrawProfit(address,address)": FunctionFragment;
    "domainSeparator()": FunctionFragment;
    "endAuction(uint256)": FunctionFragment;
    "endAuctionBySig(uint256,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "forceEndListing()": FunctionFragment;
    "forceReturnERC20(address,uint256,address)": FunctionFragment;
    "forceReturnERC721(address,address,uint256)": FunctionFragment;
    "forceReturnNative(uint256,address)": FunctionFragment;
    "getAuction(uint256)": FunctionFragment;
    "getAuctionByNFT(address,uint256)": FunctionFragment;
    "getBidding(address)": FunctionFragment;
    "getByNFT(address,uint256)": FunctionFragment;
    "getCurrentBid(uint256,address)": FunctionFragment;
    "getListing(uint256)": FunctionFragment;
    "getListingByNFT(address,uint256)": FunctionFragment;
    "getProfit(address,address)": FunctionFragment;
    "getRoleAdmin(bytes32)": FunctionFragment;
    "grantRole(bytes32,address)": FunctionFragment;
    "hasRole(bytes32,address)": FunctionFragment;
    "initialize()": FunctionFragment;
    "list(address,uint256,uint256,address)": FunctionFragment;
    "listBySig(address,uint256,uint256,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "listExists(address,uint256,address,uint256,address)": FunctionFragment;
    "listPackage(uint256,uint256,address)": FunctionFragment;
    "name()": FunctionFragment;
    "nfts(address)": FunctionFragment;
    "nonces(address)": FunctionFragment;
    "profit(address,address)": FunctionFragment;
    "renounceRole(bytes32,address)": FunctionFragment;
    "revokeRole(bytes32,address)": FunctionFragment;
    "setCurrency(address,bool)": FunctionFragment;
    "setNFT(address,(bool,uint256,uint256,address,uint256))": FunctionFragment;
    "setTeam(address)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "unList(uint256)": FunctionFragment;
    "unListBySig(uint256,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "unListPackage(uint256)": FunctionFragment;
    "updatePrice(uint256,uint256)": FunctionFragment;
    "withdraw(uint256,address)": FunctionFragment;
    "withdrawProfit(address,address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "CREATE_AUCTION_TYPE_HASH"
      | "DEFAULT_ADMIN_ROLE"
      | "DOMAIN_TYPE_HASH"
      | "END_AUCTION_TYPE_HASH"
      | "LIST_TYPE_HASH"
      | "OPERATION_ROLE"
      | "OWNER_ROLE"
      | "UN_LIST_TYPE_HASH"
      | "bid"
      | "buy"
      | "buyPackage"
      | "createAuction"
      | "createAuctionBySig"
      | "cvWithdrawProfit"
      | "domainSeparator"
      | "endAuction"
      | "endAuctionBySig"
      | "forceEndListing"
      | "forceReturnERC20"
      | "forceReturnERC721"
      | "forceReturnNative"
      | "getAuction"
      | "getAuctionByNFT"
      | "getBidding"
      | "getByNFT"
      | "getCurrentBid"
      | "getListing"
      | "getListingByNFT"
      | "getProfit"
      | "getRoleAdmin"
      | "grantRole"
      | "hasRole"
      | "initialize"
      | "list"
      | "listBySig"
      | "listExists"
      | "listPackage"
      | "name"
      | "nfts"
      | "nonces"
      | "profit"
      | "renounceRole"
      | "revokeRole"
      | "setCurrency"
      | "setNFT"
      | "setTeam"
      | "supportsInterface"
      | "unList"
      | "unListBySig"
      | "unListPackage"
      | "updatePrice"
      | "withdraw"
      | "withdrawProfit"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "CREATE_AUCTION_TYPE_HASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DEFAULT_ADMIN_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DOMAIN_TYPE_HASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "END_AUCTION_TYPE_HASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "LIST_TYPE_HASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "OPERATION_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "OWNER_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "UN_LIST_TYPE_HASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "bid",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "buy",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "buyPackage",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "createAuction",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createAuctionBySig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cvWithdrawProfit",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "domainSeparator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "endAuction",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "endAuctionBySig",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forceEndListing",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "forceReturnERC20",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forceReturnERC721",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forceReturnNative",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAuction",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAuctionByNFT",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBidding",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getByNFT",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentBid",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getListing",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getListingByNFT",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProfit",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoleAdmin",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "grantRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "list",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "listBySig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "listExists",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "listPackage",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "nfts",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "nonces",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "profit",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "revokeRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCurrency",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setNFT",
    values: [PromiseOrValue<string>, IMarketService.NFTStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setTeam",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "unList",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "unListBySig",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "unListPackage",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePrice",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawProfit",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "CREATE_AUCTION_TYPE_HASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DEFAULT_ADMIN_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DOMAIN_TYPE_HASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "END_AUCTION_TYPE_HASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "LIST_TYPE_HASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "OPERATION_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "OWNER_ROLE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "UN_LIST_TYPE_HASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "bid", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "buy", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "buyPackage", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createAuction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createAuctionBySig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cvWithdrawProfit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "domainSeparator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "endAuction", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "endAuctionBySig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceEndListing",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceReturnERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceReturnERC721",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceReturnNative",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getAuction", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAuctionByNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getBidding", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getByNFT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentBid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getListing", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getListingByNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getProfit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getRoleAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "grantRole", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "list", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "listBySig", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "listExists", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "listPackage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nfts", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "profit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "revokeRole", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setCurrency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setNFT", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setTeam", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unList", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unListBySig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unListPackage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawProfit",
    data: BytesLike
  ): Result;

  events: {
    "AddNFT(address,bool)": EventFragment;
    "Bid(uint256,address,uint256)": EventFragment;
    "Currency(address,bool)": EventFragment;
    "EndAuction(uint256)": EventFragment;
    "ForceReturn(bool)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "Listed(uint256,address,uint256,bool)": EventFragment;
    "RoleAdminChanged(bytes32,bytes32,bytes32)": EventFragment;
    "RoleGranted(bytes32,address,address)": EventFragment;
    "RoleRevoked(bytes32,address,address)": EventFragment;
    "SetNFT(address,tuple)": EventFragment;
    "SetPercentProfit(uint256)": EventFragment;
    "SetTeam(address)": EventFragment;
    "Sold(uint256,address,uint256,address,bool)": EventFragment;
    "SoldPackage(uint256,address,uint256,address,uint256)": EventFragment;
    "Unlisted(uint256)": EventFragment;
    "UpdatePrice(uint256,uint256)": EventFragment;
    "Withdraw(uint256,address,address,uint256)": EventFragment;
    "WithdrawProfit(address,address,uint256,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AddNFT"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Bid"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Currency"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EndAuction"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ForceReturn"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Listed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleAdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleGranted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleRevoked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetNFT"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetPercentProfit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetTeam"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Sold"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SoldPackage"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unlisted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatePrice"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WithdrawProfit"): EventFragment;
}

export interface AddNFTEventObject {
  nft: string;
  status: boolean;
}
export type AddNFTEvent = TypedEvent<[string, boolean], AddNFTEventObject>;

export type AddNFTEventFilter = TypedEventFilter<AddNFTEvent>;

export interface BidEventObject {
  auctionId: BigNumber;
  bidder: string;
  amount: BigNumber;
}
export type BidEvent = TypedEvent<
  [BigNumber, string, BigNumber],
  BidEventObject
>;

export type BidEventFilter = TypedEventFilter<BidEvent>;

export interface CurrencyEventObject {
  currency: string;
  status: boolean;
}
export type CurrencyEvent = TypedEvent<[string, boolean], CurrencyEventObject>;

export type CurrencyEventFilter = TypedEventFilter<CurrencyEvent>;

export interface EndAuctionEventObject {
  auctionId: BigNumber;
}
export type EndAuctionEvent = TypedEvent<[BigNumber], EndAuctionEventObject>;

export type EndAuctionEventFilter = TypedEventFilter<EndAuctionEvent>;

export interface ForceReturnEventObject {
  force: boolean;
}
export type ForceReturnEvent = TypedEvent<[boolean], ForceReturnEventObject>;

export type ForceReturnEventFilter = TypedEventFilter<ForceReturnEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface ListedEventObject {
  listingId: BigNumber;
  nft: string;
  tokenId: BigNumber;
  auction: boolean;
}
export type ListedEvent = TypedEvent<
  [BigNumber, string, BigNumber, boolean],
  ListedEventObject
>;

export type ListedEventFilter = TypedEventFilter<ListedEvent>;

export interface RoleAdminChangedEventObject {
  role: string;
  previousAdminRole: string;
  newAdminRole: string;
}
export type RoleAdminChangedEvent = TypedEvent<
  [string, string, string],
  RoleAdminChangedEventObject
>;

export type RoleAdminChangedEventFilter =
  TypedEventFilter<RoleAdminChangedEvent>;

export interface RoleGrantedEventObject {
  role: string;
  account: string;
  sender: string;
}
export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  RoleGrantedEventObject
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export interface RoleRevokedEventObject {
  role: string;
  account: string;
  sender: string;
}
export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  RoleRevokedEventObject
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export interface SetNFTEventObject {
  nft: string;
  listingFee: IMarketService.NFTStructOutput;
}
export type SetNFTEvent = TypedEvent<
  [string, IMarketService.NFTStructOutput],
  SetNFTEventObject
>;

export type SetNFTEventFilter = TypedEventFilter<SetNFTEvent>;

export interface SetPercentProfitEventObject {
  percentChainVerseTeam: BigNumber;
}
export type SetPercentProfitEvent = TypedEvent<
  [BigNumber],
  SetPercentProfitEventObject
>;

export type SetPercentProfitEventFilter =
  TypedEventFilter<SetPercentProfitEvent>;

export interface SetTeamEventObject {
  chainverseTeam: string;
}
export type SetTeamEvent = TypedEvent<[string], SetTeamEventObject>;

export type SetTeamEventFilter = TypedEventFilter<SetTeamEvent>;

export interface SoldEventObject {
  listingId: BigNumber;
  nft: string;
  tokenId: BigNumber;
  buyer: string;
  auction: boolean;
}
export type SoldEvent = TypedEvent<
  [BigNumber, string, BigNumber, string, boolean],
  SoldEventObject
>;

export type SoldEventFilter = TypedEventFilter<SoldEvent>;

export interface SoldPackageEventObject {
  listingId: BigNumber;
  nft: string;
  tokenId: BigNumber;
  buyer: string;
  amount: BigNumber;
}
export type SoldPackageEvent = TypedEvent<
  [BigNumber, string, BigNumber, string, BigNumber],
  SoldPackageEventObject
>;

export type SoldPackageEventFilter = TypedEventFilter<SoldPackageEvent>;

export interface UnlistedEventObject {
  listingId: BigNumber;
}
export type UnlistedEvent = TypedEvent<[BigNumber], UnlistedEventObject>;

export type UnlistedEventFilter = TypedEventFilter<UnlistedEvent>;

export interface UpdatePriceEventObject {
  listingId: BigNumber;
  price: BigNumber;
}
export type UpdatePriceEvent = TypedEvent<
  [BigNumber, BigNumber],
  UpdatePriceEventObject
>;

export type UpdatePriceEventFilter = TypedEventFilter<UpdatePriceEvent>;

export interface WithdrawEventObject {
  auctionId: BigNumber;
  bidder: string;
  currency: string;
  bid: BigNumber;
}
export type WithdrawEvent = TypedEvent<
  [BigNumber, string, string, BigNumber],
  WithdrawEventObject
>;

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;

export interface WithdrawProfitEventObject {
  nft: string;
  currency: string;
  amount: BigNumber;
  receiver: string;
}
export type WithdrawProfitEvent = TypedEvent<
  [string, string, BigNumber, string],
  WithdrawProfitEventObject
>;

export type WithdrawProfitEventFilter = TypedEventFilter<WithdrawProfitEvent>;

export interface MarketService extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MarketServiceInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    CREATE_AUCTION_TYPE_HASH(overrides?: CallOverrides): Promise<[string]>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    DOMAIN_TYPE_HASH(overrides?: CallOverrides): Promise<[string]>;

    END_AUCTION_TYPE_HASH(overrides?: CallOverrides): Promise<[string]>;

    LIST_TYPE_HASH(overrides?: CallOverrides): Promise<[string]>;

    OPERATION_ROLE(overrides?: CallOverrides): Promise<[string]>;

    OWNER_ROLE(overrides?: CallOverrides): Promise<[string]>;

    UN_LIST_TYPE_HASH(overrides?: CallOverrides): Promise<[string]>;

    bid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    buy(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    buyPackage(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createAuction(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      initValue: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createAuctionBySig(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      initValue: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      duration: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cvWithdrawProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    domainSeparator(overrides?: CallOverrides): Promise<[string]>;

    endAuction(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    endAuctionBySig(
      auctionId: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceEndListing(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceReturnERC20(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceReturnERC721(
      token: PromiseOrValue<string>,
      sendTo: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceReturnNative(
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAuction(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MarketService.AuctionStructOutput]>;

    getAuctionByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MarketService.AuctionStructOutput]>;

    getBidding(
      buyer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        auctionIds: BigNumber[];
        amounts: BigNumber[];
      }
    >;

    getByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [MarketService.AuctionStructOutput, MarketService.ListingStructOutput] & {
        auction: MarketService.AuctionStructOutput;
        listing: MarketService.ListingStructOutput;
      }
    >;

    getCurrentBid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidder: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getListing(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MarketService.ListingStructOutput]>;

    getListingByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MarketService.ListingStructOutput]>;

    getProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    list(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    listBySig(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    listExists(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      price: PromiseOrValue<BigNumberish>,
      fundReceiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    listPackage(
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<[string]>;

    nfts(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, BigNumber, string, BigNumber] & {
        isSupport: boolean;
        listingFee: BigNumber;
        auctionFee: BigNumber;
        nftTeam: string;
        percentNFTTeam: BigNumber;
      }
    >;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    profit(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amount: BigNumber;
        chainVerseTeam: BigNumber;
        nftTeam: BigNumber;
      }
    >;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCurrency(
      currency: PromiseOrValue<string>,
      state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setNFT(
      nft: PromiseOrValue<string>,
      nftSetting: IMarketService.NFTStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTeam(
      _team: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    unList(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unListBySig(
      listingId: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unListPackage(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updatePrice(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      auctionId: PromiseOrValue<BigNumberish>,
      bidder: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  CREATE_AUCTION_TYPE_HASH(overrides?: CallOverrides): Promise<string>;

  DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  DOMAIN_TYPE_HASH(overrides?: CallOverrides): Promise<string>;

  END_AUCTION_TYPE_HASH(overrides?: CallOverrides): Promise<string>;

  LIST_TYPE_HASH(overrides?: CallOverrides): Promise<string>;

  OPERATION_ROLE(overrides?: CallOverrides): Promise<string>;

  OWNER_ROLE(overrides?: CallOverrides): Promise<string>;

  UN_LIST_TYPE_HASH(overrides?: CallOverrides): Promise<string>;

  bid(
    auctionId: PromiseOrValue<BigNumberish>,
    bidPrice: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  buy(
    listingId: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  buyPackage(
    listingId: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createAuction(
    nft: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    initValue: PromiseOrValue<BigNumberish>,
    currency: PromiseOrValue<string>,
    duration: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createAuctionBySig(
    nft: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    initValue: PromiseOrValue<BigNumberish>,
    currency: PromiseOrValue<string>,
    duration: PromiseOrValue<BigNumberish>,
    nonce: PromiseOrValue<BigNumberish>,
    expiry: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cvWithdrawProfit(
    nft: PromiseOrValue<string>,
    currency: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  domainSeparator(overrides?: CallOverrides): Promise<string>;

  endAuction(
    auctionId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  endAuctionBySig(
    auctionId: PromiseOrValue<BigNumberish>,
    nonce: PromiseOrValue<BigNumberish>,
    expiry: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceEndListing(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceReturnERC20(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    sendTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceReturnERC721(
    token: PromiseOrValue<string>,
    sendTo: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceReturnNative(
    amount: PromiseOrValue<BigNumberish>,
    sendTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAuction(
    auctionId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MarketService.AuctionStructOutput>;

  getAuctionByNFT(
    nft: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MarketService.AuctionStructOutput>;

  getBidding(
    buyer: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber[]] & {
      auctionIds: BigNumber[];
      amounts: BigNumber[];
    }
  >;

  getByNFT(
    nft: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [MarketService.AuctionStructOutput, MarketService.ListingStructOutput] & {
      auction: MarketService.AuctionStructOutput;
      listing: MarketService.ListingStructOutput;
    }
  >;

  getCurrentBid(
    auctionId: PromiseOrValue<BigNumberish>,
    bidder: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getListing(
    listingId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MarketService.ListingStructOutput>;

  getListingByNFT(
    nft: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MarketService.ListingStructOutput>;

  getProfit(
    nft: PromiseOrValue<string>,
    currency: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getRoleAdmin(
    role: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  grantRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  hasRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  initialize(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  list(
    nft: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    currency: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  listBySig(
    nft: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    currency: PromiseOrValue<string>,
    nonce: PromiseOrValue<BigNumberish>,
    expiry: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  listExists(
    nft: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    currency: PromiseOrValue<string>,
    price: PromiseOrValue<BigNumberish>,
    fundReceiver: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  listPackage(
    tokenId: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    currency: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  nfts(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [boolean, BigNumber, BigNumber, string, BigNumber] & {
      isSupport: boolean;
      listingFee: BigNumber;
      auctionFee: BigNumber;
      nftTeam: string;
      percentNFTTeam: BigNumber;
    }
  >;

  nonces(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  profit(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      amount: BigNumber;
      chainVerseTeam: BigNumber;
      nftTeam: BigNumber;
    }
  >;

  renounceRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  revokeRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCurrency(
    currency: PromiseOrValue<string>,
    state: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setNFT(
    nft: PromiseOrValue<string>,
    nftSetting: IMarketService.NFTStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTeam(
    _team: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  unList(
    listingId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unListBySig(
    listingId: PromiseOrValue<BigNumberish>,
    nonce: PromiseOrValue<BigNumberish>,
    expiry: PromiseOrValue<BigNumberish>,
    v: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BytesLike>,
    s: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unListPackage(
    listingId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updatePrice(
    listingId: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    auctionId: PromiseOrValue<BigNumberish>,
    bidder: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawProfit(
    nft: PromiseOrValue<string>,
    currency: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    CREATE_AUCTION_TYPE_HASH(overrides?: CallOverrides): Promise<string>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    DOMAIN_TYPE_HASH(overrides?: CallOverrides): Promise<string>;

    END_AUCTION_TYPE_HASH(overrides?: CallOverrides): Promise<string>;

    LIST_TYPE_HASH(overrides?: CallOverrides): Promise<string>;

    OPERATION_ROLE(overrides?: CallOverrides): Promise<string>;

    OWNER_ROLE(overrides?: CallOverrides): Promise<string>;

    UN_LIST_TYPE_HASH(overrides?: CallOverrides): Promise<string>;

    bid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    buy(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    buyPackage(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    createAuction(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      initValue: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createAuctionBySig(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      initValue: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      duration: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cvWithdrawProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    domainSeparator(overrides?: CallOverrides): Promise<string>;

    endAuction(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    endAuctionBySig(
      auctionId: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    forceEndListing(overrides?: CallOverrides): Promise<void>;

    forceReturnERC20(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    forceReturnERC721(
      token: PromiseOrValue<string>,
      sendTo: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    forceReturnNative(
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    getAuction(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MarketService.AuctionStructOutput>;

    getAuctionByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MarketService.AuctionStructOutput>;

    getBidding(
      buyer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        auctionIds: BigNumber[];
        amounts: BigNumber[];
      }
    >;

    getByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [MarketService.AuctionStructOutput, MarketService.ListingStructOutput] & {
        auction: MarketService.AuctionStructOutput;
        listing: MarketService.ListingStructOutput;
      }
    >;

    getCurrentBid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidder: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getListing(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MarketService.ListingStructOutput>;

    getListingByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MarketService.ListingStructOutput>;

    getProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    initialize(overrides?: CallOverrides): Promise<void>;

    list(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    listBySig(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    listExists(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      price: PromiseOrValue<BigNumberish>,
      fundReceiver: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    listPackage(
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    nfts(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, BigNumber, string, BigNumber] & {
        isSupport: boolean;
        listingFee: BigNumber;
        auctionFee: BigNumber;
        nftTeam: string;
        percentNFTTeam: BigNumber;
      }
    >;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    profit(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amount: BigNumber;
        chainVerseTeam: BigNumber;
        nftTeam: BigNumber;
      }
    >;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setCurrency(
      currency: PromiseOrValue<string>,
      state: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setNFT(
      nft: PromiseOrValue<string>,
      nftSetting: IMarketService.NFTStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    setTeam(
      _team: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    unList(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    unListBySig(
      listingId: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    unListPackage(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updatePrice(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    withdraw(
      auctionId: PromiseOrValue<BigNumberish>,
      bidder: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    withdrawProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "AddNFT(address,bool)"(nft?: null, status?: null): AddNFTEventFilter;
    AddNFT(nft?: null, status?: null): AddNFTEventFilter;

    "Bid(uint256,address,uint256)"(
      auctionId?: null,
      bidder?: null,
      amount?: null
    ): BidEventFilter;
    Bid(auctionId?: null, bidder?: null, amount?: null): BidEventFilter;

    "Currency(address,bool)"(
      currency?: null,
      status?: null
    ): CurrencyEventFilter;
    Currency(currency?: null, status?: null): CurrencyEventFilter;

    "EndAuction(uint256)"(auctionId?: null): EndAuctionEventFilter;
    EndAuction(auctionId?: null): EndAuctionEventFilter;

    "ForceReturn(bool)"(force?: null): ForceReturnEventFilter;
    ForceReturn(force?: null): ForceReturnEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "Listed(uint256,address,uint256,bool)"(
      listingId?: null,
      nft?: PromiseOrValue<string> | null,
      tokenId?: null,
      auction?: null
    ): ListedEventFilter;
    Listed(
      listingId?: null,
      nft?: PromiseOrValue<string> | null,
      tokenId?: null,
      auction?: null
    ): ListedEventFilter;

    "RoleAdminChanged(bytes32,bytes32,bytes32)"(
      role?: PromiseOrValue<BytesLike> | null,
      previousAdminRole?: PromiseOrValue<BytesLike> | null,
      newAdminRole?: PromiseOrValue<BytesLike> | null
    ): RoleAdminChangedEventFilter;
    RoleAdminChanged(
      role?: PromiseOrValue<BytesLike> | null,
      previousAdminRole?: PromiseOrValue<BytesLike> | null,
      newAdminRole?: PromiseOrValue<BytesLike> | null
    ): RoleAdminChangedEventFilter;

    "RoleGranted(bytes32,address,address)"(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleGrantedEventFilter;

    "RoleRevoked(bytes32,address,address)"(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleRevokedEventFilter;

    "SetNFT(address,tuple)"(nft?: null, listingFee?: null): SetNFTEventFilter;
    SetNFT(nft?: null, listingFee?: null): SetNFTEventFilter;

    "SetPercentProfit(uint256)"(
      percentChainVerseTeam?: null
    ): SetPercentProfitEventFilter;
    SetPercentProfit(percentChainVerseTeam?: null): SetPercentProfitEventFilter;

    "SetTeam(address)"(chainverseTeam?: null): SetTeamEventFilter;
    SetTeam(chainverseTeam?: null): SetTeamEventFilter;

    "Sold(uint256,address,uint256,address,bool)"(
      listingId?: null,
      nft?: PromiseOrValue<string> | null,
      tokenId?: null,
      buyer?: null,
      auction?: null
    ): SoldEventFilter;
    Sold(
      listingId?: null,
      nft?: PromiseOrValue<string> | null,
      tokenId?: null,
      buyer?: null,
      auction?: null
    ): SoldEventFilter;

    "SoldPackage(uint256,address,uint256,address,uint256)"(
      listingId?: null,
      nft?: PromiseOrValue<string> | null,
      tokenId?: null,
      buyer?: null,
      amount?: null
    ): SoldPackageEventFilter;
    SoldPackage(
      listingId?: null,
      nft?: PromiseOrValue<string> | null,
      tokenId?: null,
      buyer?: null,
      amount?: null
    ): SoldPackageEventFilter;

    "Unlisted(uint256)"(listingId?: null): UnlistedEventFilter;
    Unlisted(listingId?: null): UnlistedEventFilter;

    "UpdatePrice(uint256,uint256)"(
      listingId?: null,
      price?: null
    ): UpdatePriceEventFilter;
    UpdatePrice(listingId?: null, price?: null): UpdatePriceEventFilter;

    "Withdraw(uint256,address,address,uint256)"(
      auctionId?: null,
      bidder?: null,
      currency?: null,
      bid?: null
    ): WithdrawEventFilter;
    Withdraw(
      auctionId?: null,
      bidder?: null,
      currency?: null,
      bid?: null
    ): WithdrawEventFilter;

    "WithdrawProfit(address,address,uint256,address)"(
      nft?: null,
      currency?: null,
      amount?: null,
      receiver?: null
    ): WithdrawProfitEventFilter;
    WithdrawProfit(
      nft?: null,
      currency?: null,
      amount?: null,
      receiver?: null
    ): WithdrawProfitEventFilter;
  };

  estimateGas: {
    CREATE_AUCTION_TYPE_HASH(overrides?: CallOverrides): Promise<BigNumber>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    DOMAIN_TYPE_HASH(overrides?: CallOverrides): Promise<BigNumber>;

    END_AUCTION_TYPE_HASH(overrides?: CallOverrides): Promise<BigNumber>;

    LIST_TYPE_HASH(overrides?: CallOverrides): Promise<BigNumber>;

    OPERATION_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    OWNER_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    UN_LIST_TYPE_HASH(overrides?: CallOverrides): Promise<BigNumber>;

    bid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    buy(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    buyPackage(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createAuction(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      initValue: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createAuctionBySig(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      initValue: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      duration: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cvWithdrawProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    domainSeparator(overrides?: CallOverrides): Promise<BigNumber>;

    endAuction(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    endAuctionBySig(
      auctionId: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceEndListing(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceReturnERC20(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceReturnERC721(
      token: PromiseOrValue<string>,
      sendTo: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceReturnNative(
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAuction(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAuctionByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBidding(
      buyer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCurrentBid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidder: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getListing(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getListingByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    list(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    listBySig(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    listExists(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      price: PromiseOrValue<BigNumberish>,
      fundReceiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    listPackage(
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    nfts(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    profit(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCurrency(
      currency: PromiseOrValue<string>,
      state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setNFT(
      nft: PromiseOrValue<string>,
      nftSetting: IMarketService.NFTStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTeam(
      _team: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unList(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unListBySig(
      listingId: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unListPackage(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updatePrice(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      auctionId: PromiseOrValue<BigNumberish>,
      bidder: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    CREATE_AUCTION_TYPE_HASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DEFAULT_ADMIN_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DOMAIN_TYPE_HASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    END_AUCTION_TYPE_HASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    LIST_TYPE_HASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    OPERATION_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    OWNER_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    UN_LIST_TYPE_HASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    buy(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    buyPackage(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createAuction(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      initValue: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createAuctionBySig(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      initValue: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      duration: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cvWithdrawProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    domainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    endAuction(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    endAuctionBySig(
      auctionId: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceEndListing(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceReturnERC20(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceReturnERC721(
      token: PromiseOrValue<string>,
      sendTo: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceReturnNative(
      amount: PromiseOrValue<BigNumberish>,
      sendTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAuction(
      auctionId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAuctionByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBidding(
      buyer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCurrentBid(
      auctionId: PromiseOrValue<BigNumberish>,
      bidder: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getListing(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getListingByNFT(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    list(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    listBySig(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    listExists(
      nft: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      price: PromiseOrValue<BigNumberish>,
      fundReceiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    listPackage(
      tokenId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nfts(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    profit(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCurrency(
      currency: PromiseOrValue<string>,
      state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setNFT(
      nft: PromiseOrValue<string>,
      nftSetting: IMarketService.NFTStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTeam(
      _team: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    unList(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unListBySig(
      listingId: PromiseOrValue<BigNumberish>,
      nonce: PromiseOrValue<BigNumberish>,
      expiry: PromiseOrValue<BigNumberish>,
      v: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BytesLike>,
      s: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unListPackage(
      listingId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updatePrice(
      listingId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      auctionId: PromiseOrValue<BigNumberish>,
      bidder: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawProfit(
      nft: PromiseOrValue<string>,
      currency: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
